"""
Calculate the envelope function for the 4-band EKPH
Method:
    - Calculate the normal wavefunction for each band
    - Calculate the Discrete Fourier Transform
    - Multiply by the Transformation matrix T
    - Calculate the inverse Discrete Fourier Transform
"""
import numpy as np


def T_S(kx, ky, kz, Eg, B, diag_band="CB"):
    """
    Determine the transformation elements of T that transform the
    diagonalized hamiltonian eigenfunction into the S envolute
    Args:
        - kx, ky, kz: 1D arrays with the coordinates
        - Eg, B: Constant values dependent on the structure
        - diag_band: Band of the diagonalized Hamiltonian (CB, LH, HH, SO)
    """
    Kx, Ky, Kz = np.meshgrid(kx, ky, kz)
    K2 = Kx**2 + Ky**2 + Kz**2
    alpha_p = Eg + np.sqrt(Eg**2 + 4 * B**2 * K2)
    if diag_band == "CB":
        return alpha_p / np.sqrt(2 * Eg * alpha_p + 8 * B**2 * K2)
    elif diag_band == "LH":
        return 2 * B * Kx / np.sqrt(2 * Eg * alpha_p + 8 * B**2 * K2)
    elif diag_band == "HH":
        return 2 * B * Ky / np.sqrt(2 * Eg * alpha_p + 8 * B**2 * K2)
    elif diag_band == "SO":
        return 2 * B * Kz / np.sqrt(2 * Eg * alpha_p + 8 * B**2 * K2)
    else:
        raise Exception("Invalid diag_band value (valid - CB, LH, HH, SO)")


def T_X(kx, ky, kz, Eg, B, diag_band="CB"):
    """
    Determine the transformation elements of T that transform the
    diagonalized hamiltonian eigenfunction into the X envolute
    Args:
        - kx, ky, kz: 1D arrays with the coordinates
        - Eg, B: Constant values dependent on the structure
        - diag_band: Band of the diagonalized Hamiltonian (CB, LH, HH, SO)
    """
    Kx, Ky, Kz = np.meshgrid(kx, ky, kz)
    if diag_band == "CB":
        return np.zeros_like(Kx)
    elif diag_band == "LH":
        return Kz / np.sqrt(Kx**2 + Kz**2)
    elif diag_band == "HH":
        return np.zeros_like(Kx)
    elif diag_band == "SO":
        return -Kx / np.sqrt(Kx**2 + Kz**2)
    else:
        raise Exception("Invalid diag_band value (valid - CB, LH, HH, SO)")


def T_Y(kx, ky, kz, Eg, B, diag_band="CB"):
    """
    Determine the transformation elements of T that transform the
    diagonalized hamiltonian eigenfunction into the Y envolute
    Args:
        - kx, ky, kz: 1D arrays with the coordinates
        - Eg, B: Constant values dependent on the structure
        - diag_band: Band of the diagonalized Hamiltonian (CB, LH, HH, SO)
    """
    Kx, Ky, Kz = np.meshgrid(kx, ky, kz)
    if diag_band == "CB":
        return np.zeros_like(Kx)
    elif diag_band == "LH":
        return -Kx * Ky / np.sqrt((Kx**2 + Kz**2) * (Kx**2 + Ky**2 + Kz**2))
    elif diag_band == "HH":
        return np.sqrt((Kz**2 + Kx**2) / (Kx**2 + Ky**2 + Kz**2))
    elif diag_band == "SO":
        return -Ky * Kz / np.sqrt((Kx**2 + Kz**2) * (Kx**2 + Ky**2 + Kz**2))
    else:
        raise Exception("Invalid diag_band value (valid - CB, LH, HH, SO)")


def T_Z(kx, ky, kz, Eg, B, diag_band="CB"):
    """
    Determine the transformation elements of T that transform the
    diagonalized hamiltonian eigenfunction into the S envolute
    Args:
        - kx, ky, kz: 1D arrays with the coordinates
        - Eg, B: Constant values dependent on the structure
        - diag_band: Band of the diagonalized Hamiltonian (CB, LH, HH, SO)
    """
    Kx, Ky, Kz = np.meshgrid(kx, ky, kz)
    K2 = Kx**2 + Ky**2 + Kz**2
    alpha_m = Eg - np.sqrt(Eg**2 + 4 * B**2 * K2)
    if diag_band == "CB":
        return alpha_m / np.sqrt(2 * Eg * alpha_m + 8 * B**2 * K2)
    elif diag_band == "LH":
        return 2 * B * Kx / np.sqrt(2 * Eg * alpha_m + 8 * B**2 * K2)
    elif diag_band == "HH":
        return 2 * B * Ky / np.sqrt(2 * Eg * alpha_m + 8 * B**2 * K2)
    elif diag_band == "SO":
        return 2 * B * Kz / np.sqrt(2 * Eg * alpha_m + 8 * B**2 * K2)
    else:
        raise Exception("Invalid diag_band value (valid - CB, LH, HH, SO)")


if __name__ == "__main__":
    # Testing Block
    # Variable initialization
    Eg = 1.5
    B = 1
    kx = np.linspace(-2, 2, 100)
    ky = np.linspace(-2, 2, 100)
    kz = np.linspace(-2, 2, 100)

    # Calculation of the S envolute
    ts = T_S(kx, ky, kz, Eg, B, "HH")
    ts_adj = np.conj(ts)
    tx = T_Y(kx, ky, kz, Eg, B, "HH")
    tx_adj = np.conj(tx)
    ty = T_Y(kx, ky, kz, Eg, B, "HH")
    ty_adj = np.conj(ty)
    tz = T_Z(kx, ky, kz, Eg, B, "HH")
    tz_adj = np.conj(tz)
    # Checks normalization of the matrices
    print(ts * ts_adj + tx * tx_adj + ty * ty_adj + tz * tz_adj)
